# Command: *explain

## Purpose
向小白用户用通俗易懂的语言解释代码更改或 issue 现状，包括为什么做、做了什么、怎么做的。

## Usage
```bash
*explain                # 解释最近一次 commit
*explain <commit>       # 解释指定的 commit
*explain last 3         # 解释最近 3 次 commit
*explain #138           # 解释 issue #138 的现状
*explain issue 138      # 同上（备选语法）
```

## Execution Steps

### Mode 1: 解释 Commit

#### 1. 获取 Commit 信息

**默认 (最近一次)**:
```bash
git log -1 --pretty=format:"%h - %s%n%n%b" --stat
```

**指定 commit**:
```bash
git show <commit> --stat
```

**多个 commit**:
```bash
git log -n <count> --pretty=format:"%h - %s" --stat
```

#### 2. 分析变更文件

```bash
# 获取变更的文件列表
git diff-tree --no-commit-id --name-status -r <commit>

# 查看具体变更
git show <commit> --unified=3
```

#### 3. 生成小白解释

使用以下结构，用通俗易懂的语言解释：

```markdown
## 📋 这次改了什么？

<一句话总结本次更改>

---

## 🤔 为什么要这样改？

### 问题背景
<用生活中的例子类比，解释遇到的问题>

### 举个例子
<具体的场景说明>

---

## 💡 具体做了什么？

### 新增的功能
- **<功能名>**: <用大白话解释这个功能是干什么的>

### 修改的代码
- **<文件名>**: <解释为什么要改这个文件，改了什么>

### 删除的内容
- **<内容>**: <解释为什么不再需要它>

---

## 🔨 怎么实现的？

### 实现思路
<用流程图或步骤说明实现逻辑>

```
步骤1: <做什么>
  ↓
步骤2: <做什么>
  ↓
步骤3: <做什么>
```

### 关键技术点
<用比喻解释技术概念>

---

## 📊 效果对比

### Before (改之前)
```
❌ <存在的问题>
```

### After (改之后)
```
✅ <解决了什么>
```

---

## 🧪 如何验证？

<告诉用户如何测试这个功能>

```bash
# 运行这个命令
<命令>

# 预期结果
<应该看到什么>
```

---

## 💭 总结

<用一句话总结：这次改动让系统变得更好在哪里>
```

---

### Mode 2: 解释 Issue

#### 1. 获取 Issue 信息

```bash
# 获取 issue 详情
gh issue view <issue-no> --json title,body,state,labels,assignees,comments,milestone

# 检查是否有关联的 commit
git log --all --grep="#<issue-no>" --oneline
```

#### 2. 检查 Issue 状态

- **OPEN**: Issue 还在进行中
- **CLOSED**: Issue 已完成

如果 closed，查找关闭的 commit：
```bash
git log --all --grep="#<issue-no>" --pretty=format:"%h - %s" -1
```

#### 3. 生成 Issue 现状解释

```markdown
## 🎯 Issue #<no>: <标题>

**当前状态**: <OPEN/CLOSED> <状态图标>

---

## 📖 这个 Issue 是做什么的？

<用大白话解释这个 issue 要解决什么问题或实现什么功能>

### 为什么需要它？

<解释为什么要做这个功能，用生活例子类比>

---

## 📍 当前进展

### [如果是 OPEN]

**状态**: 🟡 进行中

**已完成**:
- <列出已经做完的部分>

**还没做**:
- <列出还需要做的部分>

**下一步**:
<说明接下来要做什么>

### [如果是 CLOSED]

**状态**: ✅ 已完成

**完成时间**: <日期>

**解决方案**:
<用简单语言说明最终是怎么解决的>

**相关代码**:
```
<关联的 commit 信息>
```

---

## 🔍 技术细节 (可选展开)

<如果需要，用小白语言解释技术实现>

---

## 🧪 如何测试？

<告诉用户如何验证这个功能>

---

## 💭 小结

<一句话总结这个 issue 的意义>
```

## Explanation Guidelines

### 1. 语言要求
- ✅ 使用大白话，避免技术术语
- ✅ 用生活中的例子类比
- ✅ 用比喻解释抽象概念
- ❌ 不使用：Pillar、Adapter、Schema 等术语
- ❌ 不假设用户有编程基础

### 2. 比喻示例

| 技术概念 | 小白比喻 |
|---------|---------|
| 集中化管理 | 就像把分散在各个房间的工具集中放到工具箱里 |
| Mock 数据 | 就像餐厅试菜时用的模型菜，不是真的食物但可以看效果 |
| 适配器重构 | 就像把每个房间的独立开关换成统一的遥控器 |
| 错误处理 | 就像给机器加上保险丝，出问题时自动断电保护 |
| 测试通过 | 就像质检员检查了所有功能，确认都能正常工作 |
| Issue 状态 | 就像任务清单上的待办事项，打勾表示完成 |
| 分支开发 | 就像在草稿纸上先画设计图，确认没问题再正式施工 |

### 3. Issue 状态图标

| 状态 | 图标 | 说明 |
|------|------|------|
| OPEN (未开始) | 🔵 | 还没开始做 |
| OPEN (进行中) | 🟡 | 正在开发中 |
| CLOSED (已完成) | ✅ | 已经做完了 |
| CLOSED (不做了) | ❌ | 决定不做这个功能 |

### 4. 结构模板

**问题导向**:
```
遇到的问题 → 为什么是问题 → 怎么解决 → 解决后的效果
```

**功能导向**:
```
要做什么 → 为什么需要 → 怎么实现 → 如何使用
```

**优化导向**:
```
原来怎样 → 有什么不好 → 现在改成怎样 → 好在哪里
```

## Examples

### Example 1: 解释最近的 Commit (Issue #138)

```markdown
## 📋 这次改了什么？

把分散在各处的"测试假数据"集中管理起来了。

---

## 🤔 为什么要这样改？

### 问题背景
就像你有多个房间，每个房间都有自己的小工具箱，里面放着相似的工具（锤子、螺丝刀）。

**问题是**：
- 每次找工具要跑好几个房间
- 同样的工具买了好多份，浪费
- 工具坏了要在每个房间都换一遍

### 举个例子
以前写"上传图片"功能时，需要假装有一个上传地址（测试用的）。
以前写"查询配额"功能时，也需要假装有一个配额数据（测试用的）。

每个功能都自己造一份假数据，代码重复，改一个要改好多地方。

---

## 💡 具体做了什么？

### 新增的功能

建了一个"统一工具箱"：`00_kernel/mocks/`

**工具箱里有两个格子**：
1. **成功工具格** (`mockOnline.ts`)
   - 假的上传地址生成器
   - 假的配额信息生成器
   - 假的删除结果生成器
   - 假的交易数据生成器

2. **失败工具格** (`mockOffline.ts`)
   - 假的网络错误（模拟断网）
   - 假的超时错误（模拟网速慢）
   - 假的服务器错误（模拟服务器挂了）

### 修改的代码

把 4 个功能模块里原本各自造假数据的代码，改成统一从"工具箱"拿：
- `adminApi.ts` - 管理员功能
- `uploadApi.ts` - 上传功能
- `quotaApi.ts` - 配额查询功能
- `transactionApi.ts` - 交易查询功能

### 删除的内容

删掉了重复的"造假数据"函数，比如：
- `createMockTransactions()` - 原来在交易模块里自己造数据
- `createMockPresign()` - 原来在上传模块里自己造数据

---

## 🔨 怎么实现的？

### 实现思路

```
步骤1: 创建统一工具箱
  ↓ (新建 00_kernel/mocks/ 文件夹)
步骤2: 把常用的"假数据生成器"都放进去
  ↓ (写 mockOnline.ts 和 mockOffline.ts)
步骤3: 修改各个功能模块
  ↓ (把原来自己造数据的代码，改成从工具箱拿)
步骤4: 删除重复代码
  ↓ (删掉每个模块里自己造数据的函数)
步骤5: 运行测试确认没问题
  ↓ (105 个测试全部通过 ✅)
```

### 关键技术点

**集中管理**：
就像超市把同类商品放在同一个货架上，方便查找和管理。

**统一接口**：
就像遥控器，不管控制哪个电器，按钮的功能都是统一的。

**减少重复**：
就像复印机，一份文件可以复印多份，不用手写多遍。

---

## 📊 效果对比

### Before (改之前)
```
❌ 每个功能模块都有自己的"造假数据"函数
❌ 代码重复，维护困难
❌ 想测试新的错误场景，要在多个地方加代码
```

### After (改之后)
```
✅ 所有假数据统一在一个地方管理
✅ 代码精简，改一个地方就行
✅ 想测试新错误，只需在工具箱里加一个函数
✅ 所有测试都通过，功能没有影响
```

---

## 🧪 如何验证？

不需要额外验证！这次改动是"内部优化"，就像整理房间：

- 东西的位置变了（代码结构变了）
- 但东西还是那些东西（功能没变）
- 使用起来完全一样（用户无感）

**自动测试结果**：
```bash
npm test
# ✅ 105 个测试全部通过
```

---

## 💭 总结

这次改动就像把家里分散的工具都放进一个工具箱：
- 找起来更方便
- 管理更简单
- 不会买重复的工具
- 房间也更整洁了

对于使用软件的人来说，完全感觉不到变化（因为功能没变）。
但对于维护代码的人来说，以后改起来更轻松了！
```

---

### Example 2: 解释 Issue #110 的现状

```markdown
## 🎯 Issue #110: Admin: Clear Cloud Data feature for Debug Panel

**当前状态**: ✅ 已完成

---

## 📖 这个 Issue 是做什么的？

这个功能是给开发者用的"一键清空云端测试数据"按钮。

### 为什么需要它？

**场景**：开发和测试时会不断上传测试图片和交易记录到云端（AWS）

**问题**：
- 测试数据越来越多，占用存储空间
- 需要手动去 AWS 控制台删除，很麻烦
- 想快速清空数据重新测试

**解决方案**：
在调试面板里加一个"清空云端数据"按钮，点一下就能删掉所有测试数据。

**比喻**：
就像手机上的"清空缓存"按钮，不用一个个应用去清理，点一下全部搞定。

---

## 📍 当前进展

**状态**: ✅ 已完成

**完成时间**: 2026-01-11

**解决方案**:

实现了一个完整的"清空云端数据"功能，包括：

1. **后端服务** (Lambda 函数)
   - 负责实际删除操作
   - 支持删除 DynamoDB 的交易记录
   - 支持删除 S3 的图片文件
   - 有安全保护（只能删自己的数据）

2. **前端界面**
   - 在调试面板里加了一个红色的"清空云端"按钮
   - 点击后会弹出确认对话框
   - 必须勾选"我理解这是不可恢复的"才能删除
   - 删除后显示删除了多少条数据

3. **安全措施**
   - 双重确认（点按钮 + 勾选框）
   - 只删除当前用户的数据
   - 开发专用（普通用户看不到这个功能）

**相关代码**:
```
功能已在开发分支完成并验证，所有组件就绪：
- Lambda 函数: infra/lambda/admin-delete-data/
- 前端组件: app/src/02_modules/debug/
- 测试: 11 个单元测试全部通过
```

---

## 🔍 技术细节 (可选展开)

### 工作流程

```
用户点击"清空云端数据"
  ↓
弹出确认对话框
  ↓
用户勾选"我理解这是不可恢复的"
  ↓
前端调用 Lambda 函数
  ↓
Lambda 查询 DynamoDB（找到该用户的所有记录）
  ↓
Lambda 批量删除记录
  ↓
Lambda 查询 S3（找到该用户的所有图片）
  ↓
Lambda 批量删除图片
  ↓
返回删除结果：删了 X 条记录，Y 张图片
  ↓
前端显示结果
```

### 安全设计

**用户隔离**：
- DynamoDB 查询条件：`WHERE userId = "当前用户"`
- S3 查询前缀：`uploads/当前用户/`
- 绝对不会误删其他人的数据

**双重保护**：
1. 点击按钮 → 弹窗警告
2. 勾选确认框 → 按钮才能点击

**开发专用**：
- 需要输入密码 `debug` 才能进入调试面板
- 发布版本会完全隐藏调试面板
- 普通用户永远看不到这个功能

---

## 🧪 如何测试？

### 前提条件
1. 进入开发模式（`npm run tauri dev`）
2. 输入密码 `debug` 进入调试面板

### 测试步骤
```bash
1. 在调试面板找到"清空云端数据"按钮（红色）
2. 点击按钮
3. 对话框弹出，勾选"我理解这是不可恢复的"
4. 点击"确认删除"
5. 等待几秒（删除中）
6. 看到提示："已删除 X 条交易和 Y 张图片"
```

### 预期结果
- ✅ 云端数据被清空
- ✅ 本地数据不受影响
- ✅ 可以重新上传测试

---

## 💭 小结

这个功能就像给开发者的调试工具箱加了一个"重置"按钮：
- 测试完想清空数据？点一下就行
- 不用跑去 AWS 控制台手动删除
- 有双重保护，不会误删
- 普通用户完全看不到，不会误触

**对开发者来说**：方便快捷，省时省力
**对用户来说**：完全不可见，没有影响
```

---

### Example 3: 解释进行中的 Issue

```markdown
## 🎯 Issue #115: Transaction List & Filters

**当前状态**: 🟡 进行中

---

## 📖 这个 Issue 是做什么的？

实现一个"交易记录列表"界面，可以查看、筛选和排序所有交易记录。

### 为什么需要它？

**场景**：用户记了很多笔账（买东西、卖东西），想要：
- 查看所有交易记录
- 按日期排序
- 按收入/支出筛选
- 搜索特定商家

**比喻**：
就像银行 APP 的"交易明细"功能，可以看到所有进出账记录。

---

## 📍 当前进展

**状态**: 🟡 进行中

**已完成**:
- ✅ 数据库结构设计
- ✅ 后端 API 已实现
- ✅ 基础 UI 设计完成

**还没做**:
- ⏳ 前端界面开发
- ⏳ 筛选功能
- ⏳ 排序功能
- ⏳ 分页加载

**下一步**:
1. 实现交易列表基础 UI
2. 添加日期筛选器
3. 添加类型筛选（收入/支出）
4. 添加排序功能
5. 测试和优化

**预计时间**: 5 小时（根据计划）

---

## 🔍 功能预览

### 界面布局
```
┌─────────────────────────────────────┐
│  交易记录                            │
├─────────────────────────────────────┤
│  [日期筛选] [类型筛选] [排序]        │
├─────────────────────────────────────┤
│  2026-01-11  Mercari  售出  ¥5,000  │
│  2026-01-10  Book Off 购入  ¥2,000  │
│  2026-01-10  Yamato   运费  ¥800    │
│  ...                                │
└─────────────────────────────────────┘
```

### 筛选功能
- 按日期范围：选择起止日期
- 按类型：全部 / 收入 / 支出
- 按状态：全部 / 已确认 / 待确认

### 排序功能
- 按日期：最新 → 最旧 或 最旧 → 最新
- 按金额：从大到小 或 从小到大

---

## 🧪 如何测试？

等功能完成后：

1. 打开应用，进入"交易"标签
2. 应该看到所有交易记录列表
3. 尝试使用筛选器
4. 尝试排序
5. 滚动查看更多记录

---

## 💭 小结

这个功能就像给你的账本加上"目录"和"索引"：
- 不用翻遍整本账本找某笔交易
- 可以快速筛选和排序
- 清楚看到所有收支情况

**目前**：还在开发中，请耐心等待 🙂
```

---

## Related Commands
- `*status` - 查看当前项目状态
- `*issue close` - 关闭当前 issue 时自动生成解释
- `*review` - Code review 时可以用 explain 辅助理解

## Notes
- 解释时优先使用用户的母语（如果用户用中文提问，就用中文解释）
- 如果 commit message 本身就很清楚，可以基于它展开
- 对于复杂的技术改动，多用图表、流程图辅助说明
- 适当使用 emoji 让解释更生动
- Issue 解释要关注"用户价值"，说明功能对使用者的好处
